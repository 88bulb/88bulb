# 剧本杀灯光控制


## 文档说明

本文档的目的是通过对剧本杀灯光效果建模和详细分析，获得指令编码的合理设计方式，希望在软件长期进化中可以不断给创作者提供更好的表达力和表现力，同时保持固件向前兼容和可扩展性。

文档会涉及（编辑使用的）编排软件，但仅限讨论相关概念，不讨论具体的界面设计。

文档最终陈列指令设计的矛盾点，并做出现阶段的设计决策。



## 背景

剧本杀声光电系统目前设计支持1-16个灯泡。每条（无线）指令包含一个16位掩码（`bitmask`），每个灯对应掩码中的1位，这样每条指令可以指定任意数量的灯执行指令内的动作。



灯的掩码位可以理解为灯的编号，按软件习惯，取值范围为0-15。设计上并不强制要求每个编号只对应一个灯，实际上很容易为多个灯分配同样的编号。如果多个灯使用同一个编号，则这些灯执行的指令将永远相同，但即便如此也不意味着编号相同的灯动作结果完全一致，因为指令可以包含随机参数值的约定，同样编号的灯也可以有不同的动作结果。

```
例如指令内可以指定灯在收到指令后的最少1秒最多3秒的时间区间内亮起，具体选择哪个时间点由灯自己产生随机等待时间，这样即使多灯使用相同编号，每个的亮起的时间也是有差别的。
```



## 基础概念

### 要素

灯效可以用**时间**，**色彩空间**，**物理空间**三种要素完备描述。时间和色彩空间可以直觉理解，物理空间需要用一个抽象的方式理解。



剧本杀环境的灯光设计无法象舞台灯光系统那样完整对物理空间建模；但因为多个灯的存在，**整体效果并不是简单的逐一设定每个灯的效果**。一方面，在创作者的心理模型中，多灯之间的效果**对比**是一个完整效果呈现。比如多个灯『依次』亮起是一种『渐进』的效果，设计者需要直接在软件里有办法表达和调整『依次』，而不是只能逐个调整亮起时间。另一方面，实际的无线指令之间有50-80ms的发送时间间隔（目前这是hardcode在C3模块里的），『依次』效果如果要追求最佳的时间准确度，应该以一条指令编码而不是逐一给每个参与的灯发送指令。



需要有个类似**物理空间中的位置**的概念描述不同的灯，我们使用**离散空间中的位置**来理解这一概念。



有时我们需要多个灯必须按照预定的顺序协同完成效果，这种情况下通常可以利用灯的编号作为效果参数，更多的时候我们只是需要它们的行为有所不同，甚至是希望同样的命令每次都不同，这种情况下我们用效果参数的范围和随机分布，来替代单一的参数值。影响一个灯的实际效果的任何一个参数，都可以加入随机性，包括时域和色彩空间的所有可变参数。



创作者需要在各种灯效的控制参数上引入变化（variation）。这种变化可以出现在时域上（加速，减速，时快时慢），可以出现在色彩空间上，也可以出现在离散空间上。当这种变化出现在离散物理空间上时，我们使用**差异（Difference）**这个词来表述每个灯的效果不同，以区别于时域和色彩空间上的变化。



差异提供了表达**对比（Contrast）**的能力，是最常用的构造冲突（Conflict）手段和人最容易感知到的环境事件。

这样一些例子都是通过差异表达的：

1. （多个灯）显示互补色（色彩空间差异）；
2. （多个灯）交替显示颜色（色彩差异在时域的变化）；
3. （多个灯）有的先开始，有的后开始（时域差异）；
4. （多个灯闪烁）有的快有的慢（时域差异）；
5. （多个灯闪烁）有的时快时慢，有的速度均匀（时域变化的差异）；

等等。



### 合成

**合成（Synthesis）**的模型如下图所示：

```
                              -----------------------
[ Time-Domain Pattern ] ----> |                     |
[    Color Space      ] ----> | Synthesis Procedure |
[    Difference       ] ----> |                     |
                              -----------------------
```

合成指令中的数据部分，描述了时域模式，色彩空间定义，和差异行为定义，这些在编程的概念上说算描述性（Declarative）的，类似html/css的逻辑；合成过程是固件中对应的执行程序，类比编程概念，算命令式（Imperative）的。



一方面受限于蓝牙指令中非常有限的编码空间，另一方面也考虑使用的灵活性，一个效果通常并不是单一一条指令指定全部行为的。所以合成过程采用了一种编程设计上习惯称为**装饰器（Decorator）**的设计模式来实现。装饰器的最直观理解就象Photoshop的多层混叠，每一层对下层的结果做修改（装饰），然后把结果传递给上层。



一个可能的例子如下图所示：

```
layer 5: [ Special Effect                   ]
layer 4: [ Multiple Cycle Brightness Change ]
layer 3: [ Per-Cycle Brightness Change      ]
layer 2: [ Color Picker                     ]
layer 1: [ Time Domain, Color Space         ]
```

最底层layer 1提供基础的时域和色彩空间的描述，它们构成所有层的**上下文（Context）**；其余每一层都算一个“装饰器”，职责是从下层获取的颜色结果和上下文信息，产生一个颜色结果交给上层；最终灯泡在某个时刻的颜色，由最顶层计算后的颜色结果决定。图中的示例为五层，实际使用开发者应该可以自己选择层数，原则上5层对绝大多数场景都是够用的。



例子：设计者希望交替显示黄色和蓝色。



Layer 1定义调色板为双色，时域的周期长度；Layer 2是颜色选择器，在周期内的前半段时间选择颜色1，后半段时间选择颜色2，；Layer 3是亮度计算器，根据当前时间点计算颜色的亮度，如果亮度一致均匀，观察者看到的就是交替颜色切换（即方波），但Layer 3也可以选择让亮度变化呈现每周期呼吸效果，正弦波，三角波，等等；Layer 4可以叠加额外的效果，例如呼吸效果的最高亮度每周期不同，可以慢慢越来越亮，然后再慢慢越来越暗；Layer 5可以在基础的双色交替、深浅变化的呼吸效果上叠加短暂的特效，例如雷雨时的不规则闪电。这样就可以在舒缓的背景下叠加前景事件，构成层次感。



如果需要差异，这里几乎每个参数都可以制造差异，包括单周期长度，呼吸深浅变化周期的长度，颜色，亮度等，创作者常常会需要同时调整多个参数表达一个意图，例如呼吸越来越深就包含了色饱和度和亮度的加强，以及周期的变长。



另一方面这个例子也显示，在合成概念模型中的要素是分布在多个层中的，例子中1层定义了基础周期，3层使用该周期，4层叠加了一个新的周期。



最后，创作者和开发者都需要理解，每一层都在生成颜色，任何一层都在根据前面一层生成的颜色，自己的功能职责和上下文情况产生新的颜色。原则上每一层计算颜色的逻辑应尽可能少的对前面的层的逻辑有依赖性假设，理想情况下每一层只需要变换一次前面的层产生的颜色值交给下一层即可。但实际上一些设计上的想法有基础假设，例如调色板是只有一个颜色，一对互补色，一个颜色阶梯，还是一组离散色彩空间，会影响到上面每一层装饰器的行为。一个随机取色的装饰器如果放在了一个单色调色板上，它即使能工作也没有意义了。



合成设计有一定的思维负担和心智壁垒，换取灵活性和可能性。如果软件开发者希望傻瓜化，可以在用户软件里『固化』效果组合，即用户只选择了一条命令，软件将其分解为一组合成指令并选择它认为的较为合适的默认参数。



### 编排

**编排（composition）**是创作者根据设想编辑灯效的过程。



我们需要某种格式的文件记录编排的结果，可以称之为**谱（Score）**。但创作者面对编排软件使用的文件格式，和最终控制器（网关）播放的格式是否需要一致，是目前阶段的一个开放问题。打个比方，两者之间的差别有些象Word和PDF的关系，一些概念只存在于编辑软件中，例如Word里的段落和锁进；在PDF里，软件只关心一个字符摆在了页面的什么位置。类似的，创作者可能需要在编排软件中有很多便利的模板和组合设定，但灯只关心一串播放指令。目前可以确定的是，控制器的**播放谱**可以定义成一个时间线上的合成指令序列，这个定义在数学上也是严格的。



在长期的软件进化过程中，编排软件使用文件格式和最终要导出给控制器的播放谱肯定会不同，问题是在什么时间开始做这件事。



### 指令

指令是指定一个整体灯光效果的部分模板。严格的说还应该区分指令的格式定义和指令实例。前者是文档里定义的该指令的编号，行为，每个参数的含义和取值范围；后者是实际发送给灯的一条指令，即所有的参数内容都已经填充值。用面向对象编程语言描述，前者相当于类，后者相当于对象。




指令涵盖合成模型的三要素：时域，色彩空间，和差异；指令设计强调整体性，所有时域和色彩空间参数均可差异化；一个完整的效果是多条指令合作的结果，即前面说的装饰器模式，这一方面是受限于蓝牙指令的编码空间限制，另一方面则是考虑效果之间的灵活组合产生无穷的可能性。



不仅指令的格式定义是一个模板，控制器在使用时需要给每个参数赋值；因为差异化设计的存在，赋值后的指令实例在抵达灯后仍然可能是一个模板，灯还需要带入自己的实际参数，包括自己的编号或者随机数；注意这种随机性可以产生连锁的影响，比如周期的启动延迟包含了随机性，最后也会导致在某个时间点，两个灯处于同一周期的不同相对位置，也因此计算出不同的颜色。



注意：指令的这种模板特性会给编排软件制造设计困难和工作量。本质上指令是模板，而创作者希望『所见即所得』，即图形化展示最终结果，这会要求创作软件能解释指令的定义。





## 色彩空间

色彩空间的设计在三个要素中最简单。



### 调色板

根据创作者的意图，可以使用不同的调色板，原则上调色板应该在layer 1。



已有的1002指令指定了单一主色，可以看作是最简单的一种调色板；根据配色意图创作者选择双色，三色，四色也都是常见的；在大多数情况下，layer 1的调色板提供色调即可，即多种颜色下只有色调不同，饱和度和亮度一致。事实上这里的饱和度和亮度应该看作是一个缺省值，如果没有上层的装饰器，灯就选择第一个颜色和缺省的饱和度/亮度显示，但大多数情况下应该有上层装饰器做颜色选择，根据时域和指令语义做出饱和度和亮度变化。



如果需要使用的颜色很多，可以考虑内置一个颜色丰富的调色板对每个颜色编号，在使用时直接设置这个调色板是当前的layer 1调色板。



上面这些例子对于“离散”颜色效果是合适的，但如果希望有颜色空间的渐变，则可能需要描述颜色空间的一个到几个点，使用曲线连接这些点，在一个周期内，可以在封闭曲线上循环，或者在一段开放曲线上往复；这种渐变的颜色可以避免在闪烁时只有呆板的颜色变化或者只有亮度变化，可以选择绘画时常用的色彩过渡方式让色彩变化看起来更自然，例如火光的颜色可以变化到橙色，明黄，和高亮度的白。



调色板设计容易保证可扩展性，所以不做更细致的讨论。创作者只需要理解在一段周期变化的灯效区间，类似音乐里四个乐句到八个乐句的一段，需要先设定一个layer 1的调色板。



## 时域

### 绝对时间长度与相对时间长度


设计约定：只有包含主周期定义的指令，可以使用绝对时间单位定义周期和延迟，其它时间长度都使用相对于周期的时间单位，例如1/2周期，1/n周期，4周期，n周期等等。


这样做的第一原因是，人对时域模式的感知实际上是和绝对速度无关的，比如唱一首歌，唱得快一点或慢一点都是同一首歌。在这个问题上，乐谱的设计可以参考。乐谱上有全音符（whole note），二分音符（half note），四分音符（quarter note）的概念，它们之间的倍率关系是清楚的。但是一个四分音符的绝对时间长度，是可以重新定义的（例如每分钟60拍或72拍），在实际的演奏中，甚至可以是根据指挥的个人理解时快时慢的。



使用相对时间单位的另一个重要收益是：以相对周期定义的装饰器可以直接复制粘贴到另一个周期设定不同的段落使用，如果装饰器内使用的是绝对时间，那重用就会成为大麻烦。



在灯谱编排过程中，创作者也会需要让一个段落整体变得快一点或慢一点，反复预览最终确定它需要的速度，如果不是相对时间设定，这个功能难以实现，用户每次拖动一个段落的边缘做伸缩操作，软件都需要全部重新计算内部的绝对时间段。



```
结论：时域模式的描述使用相对时间单位。
```



### 周期，超周期，子周期

**周期（cycle）**的概念类似乐谱里的小节（bar，or measurement）。



但这么说有一点误导性。因为即使在音乐里，一个小节也不意味着它就是实际的乐句的周期，一个乐句的周期可能包含4个，8个，12个或更多数量的小节，或者一个轮指或三连音只有四分音符的长度。这些情况说明小节，或者周期，只是时域描述中的一个**参考时间区间**。



这就象我们在笛卡尔坐标系上要画出一个原点的位置。重要的不是这个原点的位置画在哪里，它可以画在任何地方，重要的是所有其它点的位置都以这个原点做参考，这样任意两个点的位置可以进行比较。如果没有一个**公共的参考点**，比较无从谈起。当我们要描述时域发生的事件时，我们也需要这样一个度量时间长度的参考定义，这是周期的含义。



创作者实际想使用的周期往往不只一个，就会遇到多周期问题，这里举两个例子说明。



第一个例子是最简单的闪烁模式，每个周期里占空比50%，创作者希望以8个周期为单位，闪烁的亮度先递增再递减。这里的『8个周期』就是第二个周期定义，且它是**基础周期**的整数倍，我们也许可以称他为**超周期（Super Cycle）**。



第二个例子里两个灯使用最小公倍数周期的方式“同步”。比如：一个灯使用2秒的周期轮转颜色，另一个灯使用3秒周期轮转颜色，两者有一个共同的6秒周期，视觉上每6秒钟两者“同步”了一次。这种设计可以分别向两个灯发送指令实现，但如果创作者希望这种效果作为**一个整体效果**定义和使用，那最好是定义成一个指令。在这种情况下，把『6秒周期』定义成周期，两个灯分别使用不同的**子周期（sub-cycle）工作**，更容易实现。同时这样设计也更符合事实，因为把两个灯看作一个整体时，它就只有6秒这个周期，而不是分开看时各自有不同的周期，使用基础周期和子周期来建立模型是恰当的。



实际上所谓超周期，周期，子周期这些概念只是周期的相对性的一个体现，一些周期**包含**了另外一些周期，这种**包含**可以用超周期和周期的关系描述，也可以用周期和子周期描述。但应该理解这只是空间自相似性的数学描述，指空间具有任意缩放下的不变性；创作者可以自由选择把哪个尺度定义为基础周期在使用上更加方便和符合直觉。



### 速度，速度变化

周期的绝对时间长度定义，实际上也是对**速度（Tempo）**的定义，因为它也定义了在单位时间内包含了多少个周期。比如：闪烁速度的快慢。



速度本身是可以变化的，这种变化很容易被感知。这个从抽象模型上看有点怪，因为我们一半说变化指的都是相对于时间的变化，比如位置变化（运动），颜色变化等等。而速度本身就是时域的特性，但这个时域的特性本身，还是可以随着时间变化的，有点类似导数还可以继续求导的意思。



但不管抽象概念上如何理解，速度的变化很容易被感知到，比如闪烁变得越来越快。



这种变化在指令内直接定义周期长度可变是最容易的。类似的效果也可以用子周期数量变化模仿，比如周期是不变的，第一个周期里有2个子周期，第二个周期里有3个子周期，以此类推，把周期内的子周期数量设计成周期序号的函数，这样子周期闪烁也在发生速度变化。但仔细想一下就会发现两者数学上不是一回事，直接调整周期的绝对时间长度可以做到每周期变化（cycle by cycle），而且时间精度更高。



### 随机周期长度

这里随机的周期长度指发生在时域的情况，即单指一个灯，它的每个周期的周期长度都是在某个取值区间里随机变化的，就是不规则的快一下慢一下。



实现这个效果没有难度，这里想说的是这种随机的快慢也能用一个严格相同的周期设计来实现。



比如闪烁的例子，也可以使用一个严格相同的周期，但每个周期内翻转的时间，即占空比随机。实际上这种设计的严格周期，是随机变化周期的平均周期的一半。这里不打算进行严格的数学计算，但想强调这样一点：对于高度自由的工具设计，实现一种效果目标的方式往往并不唯一，有时是象这个例子里不同设计但可以做到严格数学一致的，有时是象前面的速度变化的例子里，可以用数学上不完全一致的方式合成，但受众未必能通过感知分辨出差异，创作者需要自己权衡利弊选择最终用哪个方式合成所需效果。



### 生命周期设计

一条指令生效的时间可以自己决定（例如12个基础周期），也可以由后续替代它的指令到达决定（新指令到来）。











## 差异

差异可以让不同的灯在同一条指令下产生不同的行为，这是差异设计的目的。



差异可以涵盖时域和色彩空间中所有可能的参数，理论上它也能差异化动作类型，例如在同样的周期下，灯的亮度波动在正弦波，方波，三角波，锯齿波中随机选择；或者不同灯的颜色变化模式在跳变和渐变之间选择，纯粹数学意义上的差异是所有编码的语义都可以差异化成为同类参数的变化区间，不限于函数参数，也包括函数类型本身。但实际编码设计要考虑通过单一指令编码的必要性和效果的可分辨性。









### 有序差异

有序差异指灯的效果和它的编号相关，包括绝对编号相关和相对编号相关。

相对编号可以这样定义：假如一条指令的掩码指定了2，3，6号灯，2，3，6可以映射到0，1，2这样连续的序号上；或者使用offset方式定义，例如2，3，6号灯里2号是最小的，所有灯在计算时都把自己的序号减去最小序号。



不管怎样定义，有序差异应该是在灯的物理位置有线性排列时使用的，目的是制造一点类似动画的空间效果，比如1234号的开始周期的时间分别延迟100ms，200ms，300ms，400ms，产生一种“依次”执行动作的感觉。



### 无序差异

无序差异指使用随机数的方式制造差异，而这种差异还分为组内随机和位内随机。



组内随机指的是一个命令中涵盖的设备之间，用随机参数制造差异。但我们前面还说过，即使多个灯使用了同一个编号，仍然可以制造差异。



实际实现上指定组内随机很容易，只需要指定某个参数是区间内随机的即可；同样的方式可以指定位内随机；但如果编辑者希望的是组内随机但**位内一致**，这个效果也是能实现的但是要有点特别设计。



组内随机但位内一致的例子可以是超过了16个灯分成了几组，每组使用同样的编号，创作者希望以组为单位随机行动，但组内的成员都是一致的。实现位内一致的关键是位内的成员要有同样的随机数生成的seed，这个seed可以用命令的sequence number叠加编号，经过hash获得，命令本身也可以包含额外的seed以提高随机性。这样编号一致的灯得到同样的参数，编号不一致的灯参数不同。

















大多数情况下编辑者会希望每个周期的工作模式发生一点变化（variation），避免单调。这种变化可能发生在：

1. 一个灯的一个周期内，例如灯的亮度在一个周期内以正弦波方式变化；
2. 一个灯不同周期内，例如在一个周期内灯交替亮暗（方波），但是不同周期的亮度是不一样的；
3. 不同灯之间，比如其它参数都一致但是不同灯的亮度不同（色彩空间参数不同的例子）；

这三种变化不是互斥的，一个效果层理论上可以同时应用三种方式，实际上则会收到编码空间的限制。





Shutter是在一个周期内是一个开关，从占空比50%，先开后关开始；它相当于一个Color Picker在Primary Color和Black之间来回选择。

| 字段         | 大小                       | 需要 |
| ------------ | -------------------------- | ---- |
| 周期         | 1 option bit + 1 data byte | 必须 |
| 周期变化     | 1 option bit +             | 可选 |
| 初始延迟     |                            | 必须 |
| 初始延迟变化 |                            | 可选 |



周期

周期变化（时域）

周期差异（离散）

延迟

延迟变化（时域）

延迟差异（离散）

调色板

函数参数

函数参数变化 - 周期内，周期编号（Super Cycle）

函数参数差异



如果需要一条指令实现背景层的可以完全定义主周期，需包含



首先考虑基础指令，基础指令要求包含：
1. 过渡期间定义
2. 周期的定义
3. 调色板的定义


```c++

```





## 时域详细定义

| type     | SubTYPE        | 周期长度不变 | 周期长度是周期编号的函数1 |
| -------- | -------------- | ------------ | ------------------------- |
| 周期长度 | 不变的周期长度 |              |                           |
|          | 变化的周期长度 |              |                           |



函数1：



13 bytes

option

period (min/max 2 bytes), 

low base (min/max 1 byte), 

high base (min/max 1 byte), 

ascending (min/max 1 byte), 

high hue(min/max 2 bytes) 

hue(min/max 2 bytes)

saturation (4 + 4 bits)

low(1 byte), 

high(1 byte)

|      |       | -    | -    |
| ---- | ----- | ---- | ---- |
| 0    | opt   |      |      |
| 1    | opt   |      |      |
| 2    | opt   |      |      |
| 3    | cycle |      |      |
| 4    | bot   |      |      |
| 5    | top   |      |      |
| 6    | up    |      |      |
| 7    | hue   |      |      |
| 8    | sat   |      |      |
| 9    | val   |      |      |
| 10   | hue   |      |      |
| 11   | sat   |      |      |
| 12   | val   |      |      |

## 6完整的例子

### 7Shutter

### L8ight Valve

























