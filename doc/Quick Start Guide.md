# Quick Start Guide

本文档是开发者用的快速上手手册。



项目之前因代码重构，模块分拆，尤其在最后发基础固件给灯厂前做覆盖测试时，做了不少必要的协议变更，旧文档的内容和代码已经不一致。在根据实际代码修改文档之前，开发者从本文档开始搭建环境和调试。



## 基础固件与功能固件

交付给灯厂预置在ROM内的固件称『基础固件』，基础固件涵盖涂鸦产测（老化）功能，照明，和OTA升级三大功能，但基础固件没有受控调整颜色和颜色变化的能力。

经过工厂老化过的灯泡（我们拿到的都是这种），上电之后如果无特殊AP触发操作，进入照明模式；在照明模式下，灯泡发送包含广播（格式下述），同时可接收Blink和Boot两个指令。Blink指令可以让灯泡闪烁5次。Boot指令让灯泡启动第二级固件，称『功能固件』。

在基础固件里启动功能固件类似一次电脑的软重启，只有几个字节的必要信息带入功能固件，灯泡的所有外设和内存全部重新初始化；这种启动方式是乐鑫为了设备可以深度休眠和唤醒设计的，本项目利用该能力实现即刻升级功能，即每次启动都可以在几秒钟内刷入新固件，简化设备的开发和维护。



## 涂鸦测试2

涂鸦测试2是老化之后，触发灯泡进入颜色循环闪烁状态的办法；该行为由涂鸦产测规范定义，是5灯测试步骤中的第二步，第一步是老化。

在灯泡上电之前，打开一个工作在2.4G频段的路由器，其SSID名称为`tuya_mdev_test2`，灯泡启动时检查到该SSID的AP就会进入5色循环呼吸状态。灯不会自动退出该状态，必须重新上电。



## 照明模式下灯泡广播


|                 | 包含在包内 | 长度（字节） | 格式和内容                 |
| --------------- | ---------- | ------------ | -------------------------- |
| magic           | 必须       | 4            | 固定为`b01bca57`(bulbcast) |
| sequence number | 必须       | 1            | `uint8_t`                  |
| device info     | 必须       | 7            | adt，下述                  |
| aging           | 必须       | 3            | adt，下述                  |
| temperature     | 必须       | 4            | adt，下述                  |
| 照明参数        | 进入照明后 | 7            | adt，下述                  |



sequence number主要是为了突破接收者的蓝牙底层的remove duplicate设置，没有其它功能特别需要该字段。但灯泡内的程序是循环递增该字段的，接收者可以利用该字段统计丢包率。



### Attribute Date Type (ADT)

ADT类似通讯协议里常用的TLV（Type-Length-Value），但是把Length放在第一个字节，Length指该字节后面的数据长度，不包含Length字节本身；type是一个字节，全局定义的，即只要使用adt定义数据采用同一个type定义表；type决定了后面的value数据的格式和含义。

#### 1. Device Info

```
length:		0x06
type: 		0x00		# 表示该adt数据是设备信息
value[0]: 	0x00 		# 表示该软硬件是当前版本的灯和基础固件
value[1]:	0xMM		# 固件的major版本号
value[2]: 	0xmm		# 固件的minor版本号
value[3]:	0xpp		# 固件的patch版本号
value[4]: 	0xaa		# 固件的pre-release标记（例如0xa1是alpha1，0xb1是beta1，0xc1是rc1等等）
```

版本号基本上对应semver定义，但简化成字节格式。

当前灯泡实际发送的device info adt应该是：

```
06 00 00 01 00 00 c1	# 即版本号为1.0.0-rc1
```



#### 2. Aging Time (in minutes)

```
length:		0x02
type:		0x01		# 老化时间
value[0]:	0xmm		# 老化过的灯泡该值应该为0x32（十进制的50，表示老化时间50分钟）。
```



#### 3. Temperature

```
length: 	0x03
type:		0x02		# 灯泡内模块温度，
value[0]: 	0xtt		# 温度值，摄氏度，整数；
value[1]:   0xof		# 温度传感器的工作温区，debug用；
```



#### 4. 照明参数

```
length:		0x06
type:		0x03		# 照明参数
value[0]:	0xnn		# 温度上限，高于该限制会开始下调亮度
value[1]:	0xnn		# 目标冷白亮度，在温度不超标时尽量达到该亮度
value[2]:	0xnn		# 混入暖白比例，照明以冷白为主，目前设置暖白大约为冷白的1/4亮度
value[3]:	0xnn		# 实际的冷白亮度
value[4]: 	0xnn		# 实际的暖白亮度
```



基础固件蓝牙广播组包代码位于`bulbboot`项目的`main/ble_adv_scan.c`文件中，函数名`ble_adv_scan`。



## Blink指令

Blink功能指照明模式下，电脑或网关或其它蓝牙设备可以向指定灯泡发送一个指令，灯泡成功收到后会闪烁5下。该功能为开发、组装、资产管理时，需要肉眼识别物理灯泡设计。



Blink数据包的长度为26字节（manufacturer data里能装载下的最大字节数），格式如下：

```
magic: 	4字节，固定为 b0 1b b0 07 (bulbboot)
mac addr: 6字节，big endian格式，和蓝牙接收器打印的字节序一致
sequence: 1字节
padding: 其余15字节全部为00
```



基础固件照明模式blink指令解析代码位于`bulbboot`项目的`main/ble_adv_scan.c`文件中，函数名`handle_mfr_data`。



## Boot指令

Boot指令让基础固件启动指定sha80值的功能固件；该固件可能已经位于设备的ota1分区，这在实际部署的设备中是大多数情况（除非功能固件的设计最终变更为每剧本一固件），在这种情况下，灯泡会直接启动功能固件，延迟大约1s；如果该固件与ota1分区的固件不符，灯开始依次执行如下动作：

1. 打开wifi，搜索ssid名称包含boot指令中给定的ssid token的ap；
2. 如果找到，使用预定义的密码连接该ap；ap需加密，wep和wpa/wpa2 personal均可；
3. 通过dhcp获取ip地址；
4. tcp连接gateway的6016端口；
5. 连接成功后发送`GET [HEX格式的SHA80]\n`给服务器；
6. 先收取头部四个字节，这四个字节是big endian的`uint32_t`，为固件长度；固件长度决定了灯泡erase flash的范围，且不得超过2M；
7. 接收固件，写入flash的ota1分区；
8. 校验；
9. 把boot指令中的group id, group member id, 当前的冷白暖白亮度，写入rtc mem；这些字段可以保持到功能固件启动后，功能固件从rtc mem中读取。



以上动作如果完全成功，灯泡进入功能固件模式；如果中途出现失败，灯泡会发出一个遗嘱数据包包含错误信息，然后自动重启。遗嘱数据包格式由其它文档详细说明，代码位于`main/ble_adv_scan.c`的`ble_adv_scan`函数内。



Boot指令也是26字节固定长度，格式如下：

```
magic:			4字节，固定为b0 1b b0 07
mac addr:		6字节，目标设备的蓝牙地址，big endian
sha80: 			10字节
boot_params:	6字节
```

### 1. sha80

sha80是sha256的前面80个bit，sha256为32字节长度，sha80正好10字节。

乐鑫的官方固件，在idf.py build之后，就自带一个sha256校验值，是bin文件的最后32个字节，也是去掉这个32字节的前面的二进制内容的sha256值。乐鑫的启动器和程序api均利用该值检查文件完整性。换句话说，开发时pc上的服务器，也可以据此检查固件完整性，以及提取sha80构造boot指令。

### 2. Boot Parameters

启动参数的六个字节分为两部分，前面四个字节是Group Id；Gateway或PC控制的AP，其ssid需包含Group Id中的前面三个字节的hex格式。例如，如果Group Id为`a1 a2 a3 a4`，则`tplink-a1a2a3`，`a1a2a3`，都是合法的Gateway AP SSID，如果出现多个符合要求的AP，灯泡只会尝试连接它第一个搜到的。这三个字节的hex格式字符串，也称为SSID Token。

启动参数的后面两个字节的第一个字节，是bitmask长度，单位是字节。例如`0x02`表示使用16bit的bitmask，`0x04`表示32bit。最后一个字节，记录该灯泡被分配到的bit，例如`0x07`表示第8位；灯泡固件会使用诸如`(1 << n)`这样的代码为自己构建bitmask；该字节也可以理解为灯泡在组内的index，zero-based。

Boot Parameter的6个字节都会写入rtc mem，带入功能阶段，这样不必再次通讯分配组id，组内id；但该约定取决于功能固件和网关固件的设计，可以使用新的约定，忽略这个组id和组内id。



## 开发环境搭建

PC模拟Gateway需要一个ESP32-C3模块开发板，跑Bulbtalk（以前叫Bluetalk）固件。该固件是一个thin modem设计，它把接收到的带有`bulbcast`和`testcast` magic的数据包解析出来打印到串口，同时把串口收到的hex格式的数据（需`\n`结尾）直接填入manufacturer data字段，组出BLE广播发送出去。即前面写的blink和boot指令都可以这样发送，同时持续侦听灯泡的广播数据包。



PC模拟Gateway开发无需频繁变更AP的SSID，一种方式是使用一个独立的路由器，工作在2.4G，关闭NAT和DHCP，直接接到电脑上，使用电脑的Internet共享功能提供dhcp和充当gateway角色，推荐使用该方式，很稳定。



PC模拟Gateway开发需用代码完成一个tcp server，侦听gateway的6016端口，在接收到`GET <SHA80 in hex>\n`字符后，先发送四字节固件长度，big endian，然后发送固件内容；实现给灯泡提供功能固件的功能。如果灯泡发送的请求里包含的SHA80无效，tcp server可直接断开连接。



在tcp server代码完成的情况下，下载固件操作可以自动或手动完成：

1. 设置好wifi ap；
2. tcp server载入需要升级的固件，侦听6016端口；
3. 在串口工具，或者在代码里组boot命令包，其中boot params的前四个字节为逻辑上的group id，倒数第二个字节目前阶段写0x02即可；最后一个字节，如果只是在调试一个灯，从0-15任何数字均可，如果是多灯，每个灯应分配不同的id，但实际上多个灯使用同一个id也不是问题，他们只是动作完全一致而已，相当于一个固定的子组；如果使用不同的id，仍可以利用bitmask实现『动态的』子组。



## TODO

我首先准备两个无功能的但是可以显示固定颜色的固件，用于开发者来回交替升级，确认上述开发环境搭建是OK的，升级过程顺畅无问题。



wifi密码群里说。



